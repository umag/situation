use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode},
    execute,
    terminal::{
        EnterAlternateScreen, LeaveAlternateScreen, disable_raw_mode,
        enable_raw_mode,
    },
};
use ratatui::{
    Frame,
    Terminal,
    backend::{Backend, CrosstermBackend},
    layout::{Alignment, Constraint, Direction, Layout},
    // text::Line, // Removed unused Line
    prelude::*,                      // Import common traits and types
    style::{Color, Modifier, Style}, // Added Style, Color, Modifier for highlighting
    widgets::{
        Block, Borders, Clear, HighlightSpacing, List, ListItem, ListState,
        Paragraph, Wrap,
    }, // Added Clear, HighlightSpacing
};
use tokio;

// Use the library crate 'situation' to access shared modules
use situation::api_client;
// Import necessary models from the library crate
use situation::api_models::{
    ChangeSet, ChangeSetSummary, CreateChangeSetV1Request,
    MergeStatusV1Response, WhoamiResponse,
}; // Ensure correct import name: MergeStatusV1Response, Added ChangeSetSummary explicitly

use std::{cmp::min, error::Error, io, time::Duration};

// Intention: Define different input modes for the application.
// Design Choice: Enum to represent distinct input states, starting with Normal and ChangeSetName input.
#[derive(Debug, Clone, PartialEq, Eq)] // Added PartialEq, Eq for comparison
enum InputMode {
    Normal,
    ChangeSetName,
}

// Intention: Define which top-level element has focus for navigation.
// Design Choice: Enum to represent focus state, starting with Workspace and ChangeSet triggers.
#[derive(Debug, Clone, PartialEq, Eq)]
enum DropdownFocus {
    Workspace,
    ChangeSet,
}

// Intention: Hold the application's state, including TUI interaction state,
// selected item details, merge status, UI flags, and dropdown state.
// Design Choice: Added fields for dropdown focus and activity. Removed show_details_pane for now,
// details will show in the main area based on selection.
#[derive(Debug, Clone)]
struct App {
    whoami_data: Option<WhoamiResponse>,
    change_sets: Option<Vec<ChangeSetSummary>>, // Use imported ChangeSetSummary
    change_set_list_state: ListState, // State for the change set list selection (now in dropdown)
    selected_change_set_details: Option<ChangeSet>, // Details of the selected change set
    selected_change_set_merge_status: Option<MergeStatusV1Response>, // Merge status of the selected change set
    current_action: Option<String>, // Feedback for ongoing actions
    input_mode: InputMode,          // Current input mode
    input_buffer: String,           // Buffer for text input
    logs: Vec<String>,
    log_scroll: usize,
    dropdown_focus: DropdownFocus, // Which dropdown trigger is focused
    changeset_dropdown_active: bool, // Is the changeset dropdown list visible?
                                   // show_details_pane: bool, // Removing this, details pane logic will be tied to selection/actions
}

impl App {
    // Intention: Create a new App instance with default values.
    fn new() -> Self {
        Self {
            whoami_data: None,
            change_sets: None,
            change_set_list_state: ListState::default(),
            selected_change_set_details: None,
            selected_change_set_merge_status: None,
            current_action: None,
            input_mode: InputMode::Normal,
            input_buffer: String::new(),
            logs: Vec::new(),
            log_scroll: 0,
            dropdown_focus: DropdownFocus::Workspace, // Start focus on workspace
            changeset_dropdown_active: false,         // Dropdown starts closed
                                                      // show_details_pane: false, // Removed
        }
    }

    // Intention: Add a log message to the internal log buffer.
    fn add_log(&mut self, message: String) {
        self.logs.push(message);
        // Optional: Trim logs if they get too long
        // const MAX_LOGS: usize = 1000;
        // if self.logs.len() > MAX_LOGS {
        //     self.logs.remove(0);
        // }
    }

    // Intention: Add a log message and automatically scroll to the bottom if needed.
    // Design Choice: Calculates the maximum scroll position based on log count and view height,
    // then sets the current scroll position to the maximum, ensuring the latest log is visible.
    // This method is intended to be used whenever a new log entry is generated by the application.
    // The `view_height` parameter should match the height constraint used for the log Paragraph in the UI.
    fn add_log_auto_scroll(&mut self, message: String, view_height: usize) {
        self.logs.push(message);
        // Calculate max scroll based on the *new* number of logs and window height
        let max_scroll = self.logs.len().saturating_sub(view_height);
        self.log_scroll = max_scroll; // Always scroll to the bottom
    }

    // Intention: Scroll the log view up by one line.
    fn scroll_logs_up(&mut self) {
        self.log_scroll = self.log_scroll.saturating_sub(1);
    }

    // Intention: Scroll the log view down by one line.
    // Design Choice: Prevent scrolling beyond the available log lines.
    fn scroll_logs_down(&mut self, view_height: usize) {
        // Calculate max scroll based on number of logs and window height
        let max_scroll = self.logs.len().saturating_sub(view_height);
        self.log_scroll = min(self.log_scroll.saturating_add(1), max_scroll);
    }

    // Intention: Move selection down in the change set list (dropdown).
    fn change_set_next(&mut self) {
        if let Some(change_sets) = &self.change_sets {
            if change_sets.is_empty() {
                return;
            } // Do nothing if empty
            let i = match self.change_set_list_state.selected() {
                Some(i) => {
                    if i >= change_sets.len() - 1 {
                        0 // Wrap around
                    } else {
                        i + 1
                    }
                }
                None => 0, // Select first if nothing selected
            };
            self.change_set_list_state.select(Some(i));
            // When selection changes, clear old details
            self.selected_change_set_details = None;
            self.selected_change_set_merge_status = None;
        }
    }

    // Intention: Move selection up in the change set list (dropdown).
    fn change_set_previous(&mut self) {
        if let Some(change_sets) = &self.change_sets {
            if change_sets.is_empty() {
                return;
            } // Do nothing if empty
            let i = match self.change_set_list_state.selected() {
                Some(i) => {
                    if i == 0 {
                        change_sets.len() - 1 // Wrap around
                    } else {
                        i - 1
                    }
                }
                None => change_sets.len() - 1, // Select last if nothing selected
            };
            self.change_set_list_state.select(Some(i));
            // When selection changes, clear old details
            self.selected_change_set_details = None;
            self.selected_change_set_merge_status = None;
        }
    }

    // Intention: Get the summary of the currently selected change set.
    // Design Choice: Helper method to avoid repetitive code.
    fn get_selected_changeset_summary(&self) -> Option<&ChangeSetSummary> {
        self.change_set_list_state.selected().and_then(|idx| {
            self.change_sets.as_ref().and_then(|css| css.get(idx))
        })
    }
}

// Intention: Entry point for the TUI application.
// Design Choice: Using tokio::main for potential async operations later (like API calls).
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Intention: Set up the terminal for TUI rendering.
    // Design Choice: Enable raw mode and enter alternate screen for a clean TUI experience.
    // Ensure terminal is restored even on panic.
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Intention: Run the main application loop.
    // Design Choice: Pass the terminal instance to the run_app function.
    let res = run_app(&mut terminal).await;

    // Intention: Restore the terminal to its original state after the application exits.
    // Design Choice: Disable raw mode, leave alternate screen, and disable mouse capture.
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Err(err) = res {
        println!("Error: {:?}", err)
    }

    Ok(())
}

// Intention: Helper function to refresh the list of change sets.
// Design Choice: Encapsulates the API call and state update logic.
async fn refresh_change_sets(app: &mut App) {
    // Define log height consistent with UI definition
    const LOG_HEIGHT: usize = 10;

    if let Some(whoami_data) = &app.whoami_data {
        let workspace_id = whoami_data.workspace_id.clone();
        app.add_log_auto_scroll(
            format!("Refreshing change sets for workspace {}...", workspace_id),
            LOG_HEIGHT,
        );
        match api_client::list_change_sets(&workspace_id).await {
            Ok((list_response, cs_logs)) => {
                // Preserve selection if possible, otherwise select first or none
                let current_selection = app.change_set_list_state.selected();
                let new_len = list_response.change_sets.len();

                if new_len == 0 {
                    app.change_set_list_state.select(None);
                } else if let Some(selected_idx) = current_selection {
                    // If previous selection index is still valid, keep it
                    if selected_idx >= new_len {
                        app.change_set_list_state.select(Some(new_len - 1)); // Select last if out of bounds
                    } else {
                        // Keep selection - no need to call select
                    }
                } else {
                    // No previous selection or list was empty, select first
                    app.change_set_list_state.select(Some(0));
                }

                app.change_sets = Some(list_response.change_sets);
                // Add logs individually to ensure auto-scroll for each
                for log in cs_logs {
                    app.add_log_auto_scroll(log, LOG_HEIGHT);
                }
                app.add_log_auto_scroll(
                    "Change set list refreshed.".to_string(),
                    LOG_HEIGHT,
                );
            }
            Err(e) => {
                app.change_set_list_state.select(None); // Ensure nothing selected on error
                let error_msg = format!("Error refreshing change sets: {}", e);
                app.add_log_auto_scroll(error_msg, LOG_HEIGHT);
            }
        }
    } else {
        app.add_log_auto_scroll(
            "Cannot refresh change sets: Whoami data not available."
                .to_string(),
            LOG_HEIGHT,
        );
    }
}

// Intention: Main application loop for handling events and rendering the UI.
// Design Choice: A loop that initializes state, fetches data, draws UI, and handles input asynchronously.
async fn run_app<B: Backend>(terminal: &mut Terminal<B>) -> io::Result<()> {
    // Intention: Initialize application state using the new constructor.
    let mut app = App::new();
    // Define log height consistent with UI definition here as well
    const LOG_HEIGHT: usize = 10;

    // Intention: Perform initial data fetch (whoami and change sets) and log the process.
    // Design Choice: Call whoami first, then list_change_sets if whoami succeeds.
    app.add_log_auto_scroll(
        "Fetching initial /whoami data...".to_string(),
        LOG_HEIGHT,
    );
    match api_client::whoami().await {
        Ok((whoami_data, whoami_logs)) => {
            let _workspace_id = whoami_data.workspace_id.clone(); // Prefix with _ as it's not directly used here
            app.whoami_data = Some(whoami_data);
            // Add logs individually to ensure auto-scroll
            for log in whoami_logs {
                app.add_log_auto_scroll(log, LOG_HEIGHT);
            }
            app.add_log_auto_scroll(
                "/whoami call successful.".to_string(),
                LOG_HEIGHT,
            );
            // Initial fetch of change sets
            refresh_change_sets(&mut app).await;
        }
        Err(e) => {
            // Log the error message for whoami failure into the app's log buffer.
            let error_msg = format!("Error fetching initial data: {}", e);
            app.add_log_auto_scroll(error_msg, LOG_HEIGHT);
            // Optionally, still print to stderr during development if helpful
            // eprintln!("Error fetching initial data: {}", e);
        }
    }

    loop {
        // Intention: Draw the current state of the UI using app state.
        terminal.draw(|f| ui(f, &app))?; // Pass app state to ui

        // Intention: Handle user input events asynchronously.
        // Design Choice: Poll for events, handle keys based on mode and dropdown state.
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                // Clone necessary data *before* the mode match
                let workspace_id =
                    app.whoami_data.as_ref().map(|d| d.workspace_id.clone());
                // Use the helper method to get selected summary/ID
                let selected_cs_summary = app.get_selected_changeset_summary();
                let selected_cs_id =
                    selected_cs_summary.map(|cs| cs.id.clone());

                match app.input_mode {
                    InputMode::Normal => {
                        let log_height = 10; // Must match the Constraint::Length in ui()

                        // Handle dropdown state first if active
                        if app.changeset_dropdown_active {
                            match key.code {
                                KeyCode::Up => app.change_set_previous(),
                                KeyCode::Down => app.change_set_next(),
                                KeyCode::Enter => {
                                    // Select item, close dropdown
                                    app.changeset_dropdown_active = false;
                                    // Clear details, they need explicit fetch now
                                    app.selected_change_set_details = None;
                                    app.selected_change_set_merge_status = None;
                                    app.current_action = None; // Clear any lingering action message
                                }
                                KeyCode::Esc => {
                                    // Close dropdown without changing selection
                                    app.changeset_dropdown_active = false;
                                    app.current_action = None;
                                }
                                // Allow Tab to close and switch focus even when dropdown is open
                                KeyCode::Tab => {
                                    app.changeset_dropdown_active = false; // Close dropdown first
                                    app.dropdown_focus =
                                        match app.dropdown_focus {
                                            DropdownFocus::Workspace => {
                                                DropdownFocus::ChangeSet
                                            }
                                            DropdownFocus::ChangeSet => {
                                                DropdownFocus::Workspace
                                            }
                                        };
                                    app.current_action = None;
                                }
                                _ => {} // Other keys ignored when dropdown is active
                            }
                        } else {
                            // Normal mode, dropdown closed
                            match key.code {
                                KeyCode::Char('q') => return Ok(()),
                                KeyCode::Char('k') => app.scroll_logs_up(),
                                KeyCode::Char('j') => {
                                    app.scroll_logs_down(log_height)
                                }
                                KeyCode::Tab => {
                                    // Switch focus between triggers
                                    app.dropdown_focus =
                                        match app.dropdown_focus {
                                            DropdownFocus::Workspace => {
                                                DropdownFocus::ChangeSet
                                            }
                                            DropdownFocus::ChangeSet => {
                                                DropdownFocus::Workspace
                                            }
                                        };
                                }
                                KeyCode::Char(' ') | KeyCode::Enter => {
                                    // Activate focused element
                                    match app.dropdown_focus {
                                        DropdownFocus::Workspace => {
                                            // Do nothing for now, workspace selection not implemented
                                            app.add_log_auto_scroll("Workspace selection not implemented.".to_string(), LOG_HEIGHT);
                                        }
                                        DropdownFocus::ChangeSet => {
                                            // If Enter is pressed on CS trigger:
                                            // 1. If dropdown is closed, open it.
                                            // 2. If dropdown was already open (shouldn't happen here, but safety), close it.
                                            // 3. If dropdown is closed AND an item is selected, fetch details.
                                            if !app.changeset_dropdown_active {
                                                if app
                                                    .change_sets
                                                    .as_ref()
                                                    .map_or(false, |cs| {
                                                        !cs.is_empty()
                                                    })
                                                {
                                                    app.changeset_dropdown_active = true; // Open dropdown
                                                    // Ensure selection is valid if opening
                                                    if app
                                                        .change_set_list_state
                                                        .selected()
                                                        .is_none()
                                                    {
                                                        app.change_set_list_state.select(Some(0));
                                                    }
                                                } else {
                                                    app.add_log_auto_scroll("No change sets to select.".to_string(), LOG_HEIGHT);
                                                }
                                            } else {
                                                // This case should be handled by the block above, but for safety:
                                                app.changeset_dropdown_active =
                                                    false;
                                            }

                                            // If Enter is pressed and dropdown is closed, fetch details for selected
                                            if !app.changeset_dropdown_active {
                                                if let (
                                                    Some(ws_id),
                                                    Some(cs_id),
                                                ) = (
                                                    workspace_id.clone(),
                                                    selected_cs_id.clone(),
                                                ) {
                                                    app.current_action = Some("Fetching details & status...".to_string());
                                                    terminal.draw(|f| {
                                                        ui(f, &app)
                                                    })?; // Redraw

                                                    // Fetch details
                                                    match api_client::get_change_set(&ws_id, &cs_id).await {
                                                        Ok((get_response, logs)) => {
                                                            app.selected_change_set_details = Some(get_response.change_set);
                                                            // Add logs individually
                                                            for log in logs {
                                                                app.add_log_auto_scroll(log, LOG_HEIGHT);
                                                            }
                                                            app.add_log_auto_scroll(format!("Details fetched for {}", cs_id), LOG_HEIGHT);
                                                        }
                                                        Err(e) => {
                                                            app.selected_change_set_details = None;
                                                            app.add_log_auto_scroll(format!("Error fetching details for {}: {}", cs_id, e), LOG_HEIGHT);
                                                        }
                                                    }
                                                    // Fetch merge status
                                                    match api_client::get_merge_status(&ws_id, &cs_id).await {
                                                        Ok((status_response, logs)) => {
                                                            app.selected_change_set_merge_status = Some(status_response);
                                                            // Add logs individually
                                                            for log in logs {
                                                                app.add_log_auto_scroll(log, LOG_HEIGHT);
                                                            }
                                                            app.add_log_auto_scroll(format!("Merge status fetched for {}", cs_id), LOG_HEIGHT);
                                                        }
                                                        Err(e) => {
                                                            app.selected_change_set_merge_status = None;
                                                            app.add_log_auto_scroll(format!("Error fetching merge status for {}: {}", cs_id, e), LOG_HEIGHT);
                                                        }
                                                    }
                                                    app.current_action = None;
                                                } else {
                                                    app.add_log_auto_scroll("Cannot fetch details: No workspace or change set selected.".to_string(), LOG_HEIGHT);
                                                }
                                            }
                                        }
                                    }
                                }

                                // --- Change Set Actions (operate on selection from state) ---
                                KeyCode::Char('d') => {
                                    if let (Some(ws_id), Some(cs_id)) = (
                                        workspace_id.clone(),
                                        selected_cs_id.clone(),
                                    ) {
                                        app.current_action = Some(format!(
                                            "Deleting {}...",
                                            cs_id
                                        ));
                                        terminal.draw(|f| ui(f, &app))?;

                                        match api_client::delete_change_set(
                                            &ws_id, &cs_id,
                                        )
                                        .await
                                        {
                                            Ok((_delete_response, logs)) => {
                                                // Add logs individually
                                                for log in logs {
                                                    app.add_log_auto_scroll(
                                                        log, LOG_HEIGHT,
                                                    );
                                                }
                                                app.add_log_auto_scroll(
                                                    format!(
                                                        "Deleted changeset {}",
                                                        cs_id
                                                    ),
                                                    LOG_HEIGHT,
                                                );
                                                // Clear details if they were for the deleted item
                                                app.selected_change_set_details = None;
                                                app.selected_change_set_merge_status = None;
                                            }
                                            Err(e) => {
                                                app.add_log_auto_scroll(format!("Error deleting changeset {}: {}", cs_id, e), LOG_HEIGHT);
                                            }
                                        }
                                        app.current_action = None;
                                        refresh_change_sets(&mut app).await; // Refresh list
                                        // After refresh, clear details again as selection might change
                                        app.selected_change_set_details = None;
                                        app.selected_change_set_merge_status =
                                            None;
                                    } else {
                                        app.add_log_auto_scroll("Cannot delete: No change set selected.".to_string(), LOG_HEIGHT);
                                    }
                                }
                                KeyCode::Char('c') => {
                                    if workspace_id.is_some() {
                                        app.input_mode =
                                            InputMode::ChangeSetName;
                                        app.input_buffer.clear();
                                        // Prompt is now handled by the input line rendering in ui()
                                        app.current_action = None; // Clear any other action
                                    } else {
                                        app.add_log_auto_scroll("Cannot create: No workspace available.".to_string(), LOG_HEIGHT);
                                    }
                                }
                                KeyCode::Char('f') => {
                                    if let (Some(ws_id), Some(cs_id)) = (
                                        workspace_id.clone(),
                                        selected_cs_id.clone(),
                                    ) {
                                        app.current_action = Some(format!(
                                            "Applying {}...",
                                            cs_id
                                        ));
                                        terminal.draw(|f| ui(f, &app))?;

                                        match api_client::force_apply_change_set(&ws_id, &cs_id).await {
                                            Ok((_apply_response, logs)) => {
                                                // Add logs individually
                                                for log in logs {
                                                    app.add_log_auto_scroll(log, LOG_HEIGHT);
                                                }
                                                app.add_log_auto_scroll(format!("Apply initiated for changeset {}", cs_id), LOG_HEIGHT);
                                                // Clear details as status might change
                                                app.selected_change_set_details = None;
                                                app.selected_change_set_merge_status = None;
                                            }
                                            Err(e) => {
                                                app.add_log_auto_scroll(format!("Error applying changeset {}: {}", cs_id, e), LOG_HEIGHT);
                                            }
                                        }
                                        app.current_action = None;
                                        refresh_change_sets(&mut app).await; // Refresh list
                                        // Clear details after refresh
                                        app.selected_change_set_details = None;
                                        app.selected_change_set_merge_status =
                                            None;
                                    } else {
                                        app.add_log_auto_scroll("Cannot apply: No change set selected.".to_string(), LOG_HEIGHT);
                                    }
                                }
                                _ => {} // Ignore other keys
                            }
                        } // End Normal Mode, dropdown closed
                    } // End Normal Mode Match KeyCode

                    InputMode::ChangeSetName => {
                        // ChangeSetName input mode key handling (mostly unchanged)
                        let current_workspace_id = workspace_id.clone();
                        match key.code {
                            KeyCode::Enter => {
                                if let Some(ws_id) = current_workspace_id {
                                    let new_cs_name =
                                        app.input_buffer.trim().to_string();
                                    if !new_cs_name.is_empty() {
                                        app.current_action = Some(format!(
                                            "Creating '{}'...",
                                            new_cs_name
                                        ));
                                        terminal.draw(|f| ui(f, &app))?;

                                        let request =
                                            CreateChangeSetV1Request {
                                                change_set_name: new_cs_name
                                                    .clone(),
                                            };

                                        match api_client::create_change_set(
                                            &ws_id, request,
                                        )
                                        .await
                                        {
                                            Ok((created_cs_response, logs)) => {
                                                // Add logs individually
                                                for log in logs {
                                                    app.add_log_auto_scroll(
                                                        log, LOG_HEIGHT,
                                                    );
                                                }
                                                app.add_log_auto_scroll(format!(
                                                    "Created changeset '{}' ({})",
                                                    created_cs_response.change_set.name,
                                                    created_cs_response.change_set.id
                                                ), LOG_HEIGHT);
                                            }
                                            Err(e) => {
                                                app.add_log_auto_scroll(format!("Error creating changeset: {}", e), LOG_HEIGHT);
                                            }
                                        }
                                        refresh_change_sets(&mut app).await;
                                        // Clear details after refresh
                                        app.selected_change_set_details = None;
                                        app.selected_change_set_merge_status =
                                            None;
                                    } else {
                                        app.add_log_auto_scroll(
                                            "Change set name cannot be empty."
                                                .to_string(),
                                            LOG_HEIGHT,
                                        );
                                    }
                                } else {
                                    app.add_log_auto_scroll(
                                        "Cannot create: Workspace ID missing."
                                            .to_string(),
                                        LOG_HEIGHT,
                                    );
                                }
                                app.input_mode = InputMode::Normal;
                                app.input_buffer.clear();
                                app.current_action = None;
                            }
                            KeyCode::Char(c) => app.input_buffer.push(c),
                            KeyCode::Backspace => {
                                app.input_buffer.pop();
                            }
                            KeyCode::Esc => {
                                app.input_mode = InputMode::Normal;
                                app.input_buffer.clear();
                                app.current_action = None;
                                app.add_log_auto_scroll(
                                    "Change set creation cancelled."
                                        .to_string(),
                                    LOG_HEIGHT,
                                );
                            }
                            _ => {}
                        }
                    } // End ChangeSetName Mode Match KeyCode
                } // End Match app.input_mode
            } // End Key Event Handling
        } // End Event Poll
        // Placeholder for other async tasks or periodic refresh if needed later
        // tokio::time::sleep(Duration::from_millis(50)).await; // Small sleep to prevent busy-looping if no events
    }
    // Note: Loop is infinite, exit happens via `return Ok(())` on 'q' press.
}

// Intention: Define the UI layout and render widgets based on application state.
// Design Choice: Top bar with dropdown triggers, main area for details, logs at the bottom.
// Dropdown list rendered conditionally as an overlay.
fn ui(f: &mut Frame, app: &App) {
    // Intention: Define main layout: Top Bar, Main Content, Logs, optional Input Line.
    let log_height = 10;
    let (log_constraint, input_constraint) =
        if app.input_mode == InputMode::ChangeSetName {
            (Constraint::Length(log_height), Constraint::Length(1))
        } else {
            (Constraint::Length(log_height), Constraint::Length(0))
        };

    let main_chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(1), // Top bar for dropdown triggers & email
            Constraint::Min(0),    // Main content area (for details)
            log_constraint,        // Log window area
            input_constraint,      // Input line area (conditional)
        ])
        .split(f.size());

    let top_bar_area = main_chunks[0];
    let content_area = main_chunks[1]; // Area for details view
    let log_area = main_chunks[2];
    let input_area = if main_chunks.len() > 3 {
        Some(main_chunks[3])
    } else {
        None
    };

    // --- Top Bar Rendering ---
    // Intention: Display Workspace trigger, Change Set trigger, and Email.
    // Design Choice: Horizontal layout. Highlight focused trigger.
    let top_bar_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(30), // Workspace trigger
            Constraint::Percentage(40), // Change Set trigger
            Constraint::Percentage(30), // Email
        ])
        .split(top_bar_area);

    let ws_trigger_area = top_bar_chunks[0];
    let cs_trigger_area = top_bar_chunks[1];
    let email_area = top_bar_chunks[2];

    // Workspace Trigger (Static for now)
    let ws_name = app
        .whoami_data
        .as_ref()
        .map_or("Loading...", |d| &d.workspace_id);
    let ws_style = if app.dropdown_focus == DropdownFocus::Workspace
        && app.input_mode == InputMode::Normal
    {
        Style::default().bg(Color::Blue).fg(Color::White) // Focused style
    } else {
        Style::default() // Normal style for the whole paragraph background/focus
    };
    // Intention: Display workspace name with color.
    // Design Choice: Use Spans within a Line to apply color only to the name.
    let ws_line = Line::from(vec![
        Span::raw(" Workspace: "),
        Span::styled(ws_name, Style::default().fg(Color::Cyan)), // Apply Cyan color here
        Span::raw(" "),
    ]);
    let ws_trigger = Paragraph::new(ws_line)
        .style(ws_style) // Apply focus style to the whole paragraph
        .block(Block::default());
    f.render_widget(ws_trigger, ws_trigger_area);

    // Change Set Trigger
    let (selected_cs_name, selected_cs_status) =
        app.get_selected_changeset_summary().map_or(
            ("Select Change Set".to_string(), "".to_string()), // Default text
            |cs| (cs.name.clone(), format!(" ({})", cs.status)), // Extract name and status
        );
    let cs_indicator = if app.changeset_dropdown_active {
        "▼"
    } else {
        "▶"
    };
    let cs_style = if app.dropdown_focus == DropdownFocus::ChangeSet
        && app.input_mode == InputMode::Normal
    {
        Style::default().bg(Color::Blue).fg(Color::White) // Focused style
    } else {
        Style::default() // Normal style for the whole paragraph background/focus
    };
    // Intention: Display change set name with color.
    // Design Choice: Use Spans within a Line to apply color only to the name.
    let cs_line = Line::from(vec![
        Span::raw(" Change Set: "),
        Span::styled(selected_cs_name, Style::default().fg(Color::Yellow)), // Apply Yellow color here
        Span::raw(selected_cs_status), // Status without color
        Span::raw(" "),
        Span::raw(cs_indicator),
        Span::raw(" "),
    ]);
    let cs_trigger = Paragraph::new(cs_line)
        .style(cs_style) // Apply focus style to the whole paragraph
        .block(Block::default());
    f.render_widget(cs_trigger, cs_trigger_area);

    // Email
    let email_text = app
        .whoami_data
        .as_ref()
        .map_or("".to_string(), |d| d.user_email.clone());
    let email_paragraph =
        Paragraph::new(email_text).alignment(Alignment::Right);
    f.render_widget(email_paragraph, email_area);

    // --- Main Content Area (Details) ---
    // Intention: Display details of the selected change set.
    // Design Choice: Render details if available, otherwise show placeholder. Use a simpler title.
    let details_block = Block::default()
        .title("Details") // Simplified title
        .borders(Borders::ALL);
    let inner_details_area = details_block.inner(content_area);
    f.render_widget(details_block, content_area);

    // Intention: Display keybindings in the main content area.
    // Design Choice: Use a static list of Lines in a Paragraph, replacing the previous details view.
    let keybindings = vec![
        Line::from(Span::styled(
            "--- Keybindings ---",
            Style::default().add_modifier(Modifier::BOLD),
        )),
        Line::from(""),
        Line::from(Span::styled(
            "Normal Mode (Dropdown Closed):",
            Style::default().add_modifier(Modifier::UNDERLINED),
        )),
        Line::from("  q          : Quit"),
        Line::from("  Tab        : Switch Focus (Workspace <-> Change Set)"),
        Line::from(
            "  Enter/Space: Activate Focused Trigger (Open Dropdown / Fetch Details)",
        ),
        Line::from("  c          : Create Change Set (Enter Input Mode)"),
        Line::from("  d          : Delete Selected Change Set"),
        Line::from("  f          : Force Apply Selected Change Set"),
        Line::from("  k          : Scroll Logs Up"),
        Line::from("  j          : Scroll Logs Down"),
        Line::from(""),
        Line::from(Span::styled(
            "Normal Mode (Change Set Dropdown Active):",
            Style::default().add_modifier(Modifier::UNDERLINED),
        )),
        Line::from("  Up Arrow   : Select Previous Item"),
        Line::from("  Down Arrow : Select Next Item"),
        Line::from("  Enter      : Confirm Selection & Close Dropdown"),
        Line::from("  Esc / Tab  : Close Dropdown"),
        Line::from(""),
        Line::from(Span::styled(
            "ChangeSetName Input Mode:",
            Style::default().add_modifier(Modifier::UNDERLINED),
        )),
        Line::from("  Enter      : Submit Name & Create"),
        Line::from("  Esc        : Cancel Input"),
        Line::from("  Backspace  : Delete Character"),
        Line::from("  (any char) : Append Character"),
    ];

    let keybindings_paragraph =
        Paragraph::new(keybindings).wrap(Wrap { trim: true });
    f.render_widget(keybindings_paragraph, inner_details_area);

    // --- Log Window Rendering (Bottom) ---
    let log_block = Block::default()
        .title("Logs (j/k: Scroll)")
        .borders(Borders::ALL);
    let inner_log_area = log_block.inner(log_area);
    f.render_widget(log_block, log_area);

    let log_lines: Vec<ratatui::text::Line> = app
        .logs
        .iter()
        .map(|log| ratatui::text::Line::from(log.as_str()))
        .collect();
    let log_paragraph = Paragraph::new(log_lines)
        .wrap(Wrap { trim: false })
        .scroll((app.log_scroll as u16, 0));
    // Store the paragraph before rendering it the first time
    let log_paragraph_clone = log_paragraph.clone();
    f.render_widget(log_paragraph, inner_log_area);

    // --- Input Line Rendering (Conditional, Bottom) ---
    if let Some(input_area) = input_area {
        if app.input_mode == InputMode::ChangeSetName {
            let input_prompt_text =
                "Enter Change Set Name (Esc: Cancel, Enter: Create):";
            let input_paragraph = Paragraph::new(format!(
                "{} {}{}",
                input_prompt_text,
                app.input_buffer,
                "_" // Simple cursor indicator
            ))
            .style(Style::default().fg(Color::Yellow));
            f.render_widget(input_paragraph, input_area);
        }
    }

    // --- Change Set Dropdown List (Overlay) ---
    // Intention: Render the dropdown list if active.
    // Design Choice: Render last, potentially overlapping content. Use Clear widget first.
    if app.changeset_dropdown_active {
        let list_height =
            app.change_sets.as_ref().map_or(1, |cs| cs.len()).min(10) as u16
                + 2; // Max 10 items + borders
        let list_width = 50; // Fixed width for dropdown

        // Calculate position below the trigger
        let list_area = Rect {
            x: cs_trigger_area.x,
            y: cs_trigger_area.y + 1, // Position below the trigger
            width: list_width.min(f.size().width - cs_trigger_area.x), // Clamp width
            height: list_height.min(f.size().height - (cs_trigger_area.y + 1)), // Clamp height
        };

        // Items for the dropdown list
        let change_set_items: Vec<ListItem> = match &app.change_sets {
            Some(change_sets) => {
                if change_sets.is_empty() {
                    vec![ListItem::new("No change sets found.")]
                } else {
                    change_sets
                        .iter()
                        .map(|cs| {
                            ListItem::new(format!(
                                "{} ({}) - {}",
                                cs.name, cs.status, cs.id
                            ))
                        })
                        .collect()
                }
            }
            None => vec![ListItem::new("Loading...")],
        };

        let dropdown_list = List::new(change_set_items)
            .block(
                Block::default()
                    .title("Select Change Set (Enter/Esc)")
                    .borders(Borders::ALL),
            )
            .highlight_style(
                Style::default()
                    .bg(Color::LightBlue)
                    .add_modifier(Modifier::BOLD),
            )
            .highlight_symbol("> ")
            .highlight_spacing(HighlightSpacing::Always); // Ensure highlight shows even if list loses focus conceptually

        // Render the dropdown list
        // Use Clear widget first to ensure it draws cleanly over existing content
        f.render_widget(Clear, list_area);
        let mut list_state = app.change_set_list_state.clone(); // Clone state for rendering
        f.render_stateful_widget(dropdown_list, list_area, &mut list_state);
    }

    // Display current action in the log area title bar maybe? Or keep it simple.
    // Let's add it to the log title
    let log_title = if let Some(action) = &app.current_action {
        format!("Logs (j/k: Scroll) - [{}]", action)
    } else {
        "Logs (j/k: Scroll)".to_string()
    };
    let log_block_with_title =
        Block::default().title(log_title).borders(Borders::ALL);
    f.render_widget(log_block_with_title, log_area); // Re-render block with potentially updated title
    // Re-render paragraph inside
    f.render_widget(log_paragraph_clone, inner_log_area); // Render the stored paragraph again
}
